"""Traffic route switches and kill switches for UniFi Network Rules integration."""
from __future__ import annotations

import logging
from typing import Any, Optional
import time
import asyncio
import copy

from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.entity import generate_entity_id
from homeassistant.helpers.entity_registry import async_get as async_get_entity_registry
from homeassistant.exceptions import HomeAssistantError

from .base import UnifiRuleSwitch
from ..const import DOMAIN, SWITCH_DELAYED_VERIFICATION_SLEEP_SECONDS
from ..coordinator import UnifiRuleUpdateCoordinator
from ..helpers.rule import (
    get_rule_id, 
    get_child_unique_id, 
    get_child_entity_name,
    get_child_entity_id,
    get_object_id,
    extract_descriptive_name,
)

LOGGER = logging.getLogger(__name__)


class UnifiTrafficRuleSwitch(UnifiRuleSwitch):
    """Switch to enable/disable a UniFi traffic rule."""
    
    def __init__(
        self,
        coordinator: UnifiRuleUpdateCoordinator,
        rule_data: Any,
        rule_type: str,
        entry_id: str = None,
    ) -> None:
        """Initialize traffic rule switch."""
        super().__init__(coordinator, rule_data, rule_type, entry_id)
        # Set icon for traffic rules
        self._attr_icon = "mdi:traffic-light"


class UnifiTrafficRouteSwitch(UnifiRuleSwitch):
    """Switch to enable/disable a UniFi traffic route rule."""
    
    def __init__(
        self,
        coordinator: UnifiRuleUpdateCoordinator,
        rule_data: Any,
        rule_type: str,
        entry_id: str = None,
    ) -> None:
        """Initialize traffic route switch."""
        super().__init__(coordinator, rule_data, rule_type, entry_id)
        # Set icon for traffic route rules
        self._attr_icon = "mdi:directions-fork"


class UnifiTrafficRouteKillSwitch(UnifiRuleSwitch):
    """Switch to enable/disable kill switch for a UniFi traffic route rule."""
    
    def __init__(
        self,
        coordinator: UnifiRuleUpdateCoordinator,
        rule_data: Any,
        rule_type: str,
        entry_id: str = None,
    ) -> None:
        """Initialize traffic route kill switch using super() and overriding."""
        # 1. Initialize using the base class with the PARENT rule data.
        # The base __init__ will set initial name, unique_id etc based on the parent.
        super().__init__(coordinator, rule_data, "traffic_routes", entry_id)

        # 2. Determine Parent and Kill Switch IDs
        original_rule_id = get_rule_id(rule_data) # Parent unique ID (e.g., unr_route_xyz)
        if not original_rule_id:
            raise ValueError("KillSwitch init: Cannot determine original rule ID from rule data")
        kill_switch_id = get_child_unique_id(original_rule_id, "kill_switch")

        # 3. Override attributes for the Kill Switch
        self._rule_id = kill_switch_id        # Internal ID used by this instance
        self._attr_unique_id = kill_switch_id # The unique ID for HA (OVERRIDE)

        # Override name based on the name generated by super()
        # Ensure super() set a name before modifying
        if self._attr_name:
            self._attr_name = get_child_entity_name(self._attr_name, "kill_switch")  # OVERRIDE
        else:
            # Fallback name if super init failed to set one
            fallback_parent_name = extract_descriptive_name(rule_data, coordinator) or original_rule_id
            self._attr_name = get_child_entity_name(fallback_parent_name, "kill_switch")

        # Override entity_id based on the object_id generated by super()
        # Note: get_object_id uses rule_data (parent), which is correct base
        parent_object_id = get_object_id(rule_data, "traffic_routes")
        kill_switch_object_id = get_child_entity_id(parent_object_id, "kill_switch")
        self.entity_id = generate_entity_id(
            "switch.{}", kill_switch_object_id, hass=coordinator.hass # OVERRIDE
        )

        # 4. Initialize kill switch state specifically
        # (Optimistic state handling is managed by base class, but we set initial value)
        self._optimistic_state = None
        self._optimistic_timestamp = 0
        if hasattr(rule_data, 'raw') and "kill_switch_enabled" in rule_data.raw:
            actual_state = rule_data.raw.get("kill_switch_enabled", False)
            self._optimistic_state = actual_state # Start optimistic state matching actual
            self._optimistic_timestamp = time.time()
            LOGGER.debug("KillSwitch %s: Initialized specific state to %s from parent rule data",
                        self.unique_id, actual_state)
        else:
            LOGGER.warning("KillSwitch %s: Initialized without specific state from rule data.", self.unique_id)

        # 5. Linking Information (Parent ID needed for lookups)
        self._linked_parent_id = original_rule_id # Store parent's unique_id
        self._linked_child_ids = set() # Kill switches have no children

        # Set icon for kill switch
        self._attr_icon = "mdi:shield-off"

        # Global tracking is now handled in base async_added_to_hass

        LOGGER.debug("Finished KillSwitch __init__ for unique_id=%s, entity_id=%s",
                    self._attr_unique_id, self.entity_id)

    @callback
    def _handle_coordinator_update(self) -> None:
        """Handle updated data from the coordinator.

        This method delegates to the base class implementation.
        The base class handles all the necessary logic:
        - Checking coordinator data validity
        - Finding the parent rule using our specialized _get_current_rule method
        - Handling optimistic state management
        - Triggering removal if the parent rule is missing
        """
        LOGGER.debug("KillSwitch(%s): Delegating coordinator update to base class", self.entity_id or self.unique_id)
        super()._handle_coordinator_update()
        
    def _get_actual_state_from_rule(self, rule: Any) -> Optional[bool]:
        """Helper to get the actual kill switch state from the PARENT rule object."""
        if rule is None:
            LOGGER.debug("KillSwitch(%s): Cannot get state, parent rule object is None.", self.entity_id or self.unique_id)
            return None

        # Check if the rule has the kill_switch_enabled attribute in raw data
        if hasattr(rule, 'raw') and isinstance(rule.raw, dict):
            state = rule.raw.get("kill_switch_enabled") # Use .get() for safety
            if state is not None:
                return state

        # Fallback: Check direct attribute if raw doesn't have it
        if hasattr(rule, 'kill_switch_enabled'):
            state = getattr(rule, 'kill_switch_enabled')
            return state

        LOGGER.warning("KillSwitch(%s): Cannot determine actual state from parent rule object %s (type: %s)",
                      self.entity_id or self.unique_id, getattr(rule, 'id', 'N/A'), type(rule).__name__)
        return None # Return None if state cannot be determined
        
    def _get_current_rule(self) -> Any | None:
        """Get the current rule from the coordinator data.
        
        Special implementation for KillSwitch that finds the PARENT rule in traffic_routes.
        Kill switches don't have their own rule objects - they are settings on parent objects.
        """
        try:
            # 1. Validate the kill switch ID format
            kill_switch_id = self._rule_id  # This should be a kill switch ID like "unr_route_abc_kill_switch"
            if not kill_switch_id or not kill_switch_id.endswith('_kill_switch'):
                LOGGER.warning("KillSwitch(%s): Invalid kill switch ID format: %s", 
                              self.entity_id, kill_switch_id)
                return None
                
            # 2. Get the parent unique ID from our stored property 
            parent_unique_id = self._linked_parent_id
            if not parent_unique_id:
                LOGGER.error("KillSwitch(%s): Cannot find parent rule - _linked_parent_id is not set!",
                            self.entity_id)
                return None
                
            # 3. Look for the parent rule in traffic_routes collection
            # The parent's rule type is always traffic_routes for kill switches
            parent_rule_type = "traffic_routes" 
            
            # Basic validations - ensure coordinator data exists
            if not self.coordinator or not self.coordinator.data or parent_rule_type not in self.coordinator.data:
                return None
                
            # Get the traffic routes collection
            traffic_routes = self.coordinator.data[parent_rule_type]
            
            # Search for the parent rule by its unique ID
            parent_rule = None
            for rule in traffic_routes:
                current_parent_unique_id = get_rule_id(rule)
                if current_parent_unique_id == parent_unique_id:
                    parent_rule = rule
                    break  # Found it
                    
            # Return the parent rule (or None if not found)
            return parent_rule
            
        except Exception as err:
            LOGGER.error("KillSwitch(%s): Error finding parent rule: %s", 
                        self.entity_id, err)
            return None

    @property
    def is_on(self) -> bool:
        """Return true if kill switch is enabled."""
        # Use optimistic state if set
        if self._optimistic_state is not None:
            return self._optimistic_state
            
        current_rule = self._get_current_rule()
        if current_rule is None:
            return False
            
        # Check if the rule has the kill_switch_enabled attribute
        if hasattr(current_rule, 'raw') and isinstance(current_rule.raw, dict):
            return current_rule.raw.get("kill_switch_enabled", False)
            
        # If the rule doesn't have the attribute, check if it has a direct kill_switch_enabled property
        if hasattr(current_rule, 'kill_switch_enabled'):
            return getattr(current_rule, 'kill_switch_enabled')
            
        # As a last resort, default to False
        LOGGER.warning("Kill switch %s cannot determine state from rule %s", 
                      self._rule_id, type(current_rule).__name__)
        return False
    
    @property
    def available(self) -> bool:
        """Return if entity is available."""
        # Add log at the very start
        LOGGER.debug("KillSwitch(%s): Evaluating available property...", self.entity_id or self.unique_id)
        
        # Start with coordinator status
        coord_ok = self.coordinator.last_update_success
        if not coord_ok:
            LOGGER.debug("KillSwitch(%s): Unavailable due to coordinator failure.", self.entity_id or self.unique_id)
            return False

        # Now check if the parent rule exists in the coordinator's data
        parent_rule = self._get_current_rule()
        is_available = parent_rule is not None

        # Log the availability status, especially if it's False
        if not is_available:
            LOGGER.debug("KillSwitch(%s): Determined unavailable because parent rule lookup failed.", self.entity_id or self.unique_id)
        else:
            # Optionally log when available too, but can be noisy
            LOGGER.debug("KillSwitch(%s): Determined available (parent rule found).", self.entity_id or self.unique_id)

        return is_available

    async def _async_toggle_rule(self, enable: bool) -> None:
        """Toggle the kill switch setting."""
        rule = self._get_current_rule()
        if rule is None:
            raise HomeAssistantError(f"Cannot find rule with ID: {self._rule_id}")

        LOGGER.debug("%s kill switch for %s", "Enabling" if enable else "Disabling", self.name)
        
        # Store current state for optimistic updates
        self._optimistic_state = enable
        self._optimistic_timestamp = time.time()
        self.async_write_ha_state()
        
        # Track the operation in coordinator for proper state management
        if hasattr(self.coordinator, "_pending_operations"):
            # Use a special key for kill switch operations to avoid conflicts with parent
            kill_switch_operation_id = f"{self._rule_id}_kill_switch"
            self.coordinator._pending_operations[kill_switch_operation_id] = enable
        
        # Register the operation with the coordinator to prevent redundant refreshes.
        change_type = "enabled" if enable else "disabled"
        entity_id = self.entity_id or f"switch.{self._rule_id}_kill_switch"
        self.coordinator.register_ha_initiated_operation(self._rule_id, entity_id, change_type)
        
        # Queue the toggle operation
        try:
            # Get the toggle function from the API client
            toggle_func = self.coordinator.api.toggle_traffic_route_kill_switch
            
            # Queue the operation using the coordinator's queue method
            future = await self.coordinator.api.queue_api_operation(toggle_func, rule)
            
            async def handle_operation_complete(future):
                """Handle the completion of the toggle operation."""
                try:
                    result = future.result()
                    if result:
                        LOGGER.debug("Successfully toggled kill switch for %s", self.name)
                        # --- Smart Verification Task ---
                        # See parent class for detailed explanation of this safety net.
                        async def delayed_verification():
                            await asyncio.sleep(SWITCH_DELAYED_VERIFICATION_SLEEP_SECONDS)
                            kill_switch_id = self._rule_id # The unique ID for the kill switch
                            if self.coordinator.check_and_consume_ha_initiated_operation(kill_switch_id):
                                LOGGER.warning("Delayed verification for kill switch %s failed. Forcing refresh.", kill_switch_id)
                                await self.coordinator.async_request_refresh()
                            else:
                                LOGGER.debug("Delayed verification for kill switch %s confirmed.", kill_switch_id)

                        self.hass.async_create_task(delayed_verification())
                    else:
                        LOGGER.error("Failed to toggle kill switch for %s", self.name)
                        # Revert optimistic state on failure
                        self._optimistic_state = not enable
                        self._optimistic_timestamp = time.time()
                        self.async_write_ha_state()
                    
                    # Clean up pending operations
                    if hasattr(self.coordinator, "_pending_operations"):
                        kill_switch_operation_id = f"{self._rule_id}_kill_switch"
                        if kill_switch_operation_id in self.coordinator._pending_operations:
                            del self.coordinator._pending_operations[kill_switch_operation_id]
                        
                except Exception as err:
                    LOGGER.error("Error in kill switch toggle operation: %s", str(err))
                
                    # Revert optimistic state on error
                    self._optimistic_state = not enable
                    self._optimistic_timestamp = time.time()
                    self.async_write_ha_state()
            
            # Add the completion callback
            future.add_done_callback(
                lambda f: self.hass.async_create_task(handle_operation_complete(f))
            )
            
            LOGGER.debug("Successfully queued kill switch toggle operation for rule %s", self._rule_id)
            
        except Exception as error:
            LOGGER.exception("Failed to queue kill switch toggle operation: %s", str(error))
            
            # Clean up pending operations if queuing failed
            if hasattr(self.coordinator, "_pending_operations"):
                kill_switch_operation_id = f"{self._rule_id}_kill_switch"
                if kill_switch_operation_id in self.coordinator._pending_operations:
                    del self.coordinator._pending_operations[kill_switch_operation_id]
            
            # Revert optimistic state
            self._optimistic_state = not enable
            self._optimistic_timestamp = time.time()
            self.async_write_ha_state()
            
            raise HomeAssistantError(f"Error toggling kill switch for {self.name}: {error}") from error


# Helper function to create kill switch entities
async def create_traffic_route_kill_switch(hass: HomeAssistant, coordinator, rule, config_entry_id=None, return_entity=False):
    """Create a kill switch entity for a traffic route.
    
    This centralized function is used by both async_setup_entry and async_create_entity 
    to ensure consistent kill switch creation.
    
    Args:
        hass: The Home Assistant instance
        coordinator: The UnifiRuleUpdateCoordinator
        rule: The traffic route rule data
        config_entry_id: The config entry ID
        return_entity: Whether to return the created entity (for async_setup_entry)
        
    Returns:
        If return_entity is True, returns the created entity or None
        Otherwise, returns True if kill switch was created, False otherwise
    """
    from .setup import _CREATED_UNIQUE_IDS  # Import the global tracker
    
    # Check if this rule has kill switch support
    if not hasattr(rule, 'raw') or "kill_switch_enabled" not in rule.raw:
        return None if return_entity else False
    
    try:
        # Get the parent rule ID
        parent_rule_id = get_rule_id(rule)
        if not parent_rule_id:
            LOGGER.error("Cannot create kill switch - parent rule has no valid ID")
            return None if return_entity else False
            
        # Generate kill switch ID
        kill_switch_id = get_child_unique_id(parent_rule_id, "kill_switch")

        # Check if already exists in registry
        entity_registry = async_get_entity_registry(hass)
        _existing_entity_id = entity_registry.async_get_entity_id("switch", DOMAIN, kill_switch_id)

        # Don't create if already created this session
        if kill_switch_id in _CREATED_UNIQUE_IDS:
            LOGGER.debug("Kill switch already created in this session: %s", kill_switch_id)
            # If it exists but we need to return it (e.g., for setup_entry linking)
            if return_entity:
                # Attempt to find the existing entity instance? This is tricky.
                # For now, returning None prevents duplicate creation attempt by setup_entry.
                # Linking logic in setup_entry will handle finding existing entities later.
                LOGGER.warning("Kill switch %s already created, returning None for setup_entry", kill_switch_id)
                return None
            return False  # Don't proceed if not returning entity

        # Create a copy of the rule for the kill switch
        rule_copy = copy.deepcopy(rule)

        # Create the kill switch entity - REMOVED parent_entity argument
        kill_switch = UnifiTrafficRouteKillSwitch(
            coordinator, rule_copy, "traffic_routes", config_entry_id
        )

        # Mark as created to prevent duplicates
        _CREATED_UNIQUE_IDS.add(kill_switch_id)

        # If called from setup_entry, just return the entity
        if return_entity:
            LOGGER.debug("Returning kill switch entity for setup_entry: %s", kill_switch_id)
            return kill_switch

        # Otherwise, add it to the platform
        platform = None
        # Ensure platform data structure exists before accessing
        if DOMAIN in hass.data and "platforms" in hass.data[DOMAIN] and "switch" in hass.data[DOMAIN]["platforms"]:
            platform = hass.data[DOMAIN]["platforms"]["switch"]

        # Add entity if platform is available
        if platform and hasattr(platform, 'async_add_entities'):
            parent_name_for_log = getattr(rule, 'name', parent_rule_id) # Get parent name if possible
            LOGGER.info("Creating kill switch entity for %s", parent_name_for_log)
            await platform.async_add_entities([kill_switch])
            return True
        else:
            LOGGER.error("Cannot create kill switch - switch platform unavailable or lacks async_add_entities method")
            # Clean up tracking if creation failed
            if kill_switch_id in _CREATED_UNIQUE_IDS:
                _CREATED_UNIQUE_IDS.remove(kill_switch_id)
            return False
    except Exception as err:
        LOGGER.error("Error creating kill switch entity: %s", err)
        # Clean up tracking on error
        kill_switch_id_on_error = get_child_unique_id(get_rule_id(rule), "kill_switch") if get_rule_id(rule) else None
        if kill_switch_id_on_error and kill_switch_id_on_error in _CREATED_UNIQUE_IDS:
            _CREATED_UNIQUE_IDS.remove(kill_switch_id_on_error)
        return None if return_entity else False
